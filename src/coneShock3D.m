function [] = coneShock3D(theta, M1, c1, gamma, Rg, common)
    %   coneShock3D: function to evaluate the shock wave generated by an axisimmetric cone
    %   in 3D at zero angle of attack
    %
    %   INPUT:
    %       theta,      double[1, 1]: cone semi apex angle [rad]
    %       M1,         double[1, 1]: free stream mach number [-]
    %       c1,         double[1, 1]: free stream sonic velocity [m/s]
    %       gamma,      double[1, 1]: specific heat ratio [-]
    %       Rg,         double[1, 1]: specific gas constant [J/K]
    %   OUTPUT:
    %
    %

    % preallocation/init
    err = 1; 
    toll = 1e-3; 

    % suppose initial beta
    beta0 = pi/4;  % shockwave angle [rad]

    T1 =  c1^2/(Rg * gamma);    % pre shock static temperature
    funBeta = @(x) computeBeta(x, theta, M1, T1, gamma, Rg, common.optOde);
    [beta, ~, exitflag] = fsolve(funBeta, beta0, common.optFsolve);

end


function dY = odeVelocityCone(th, Y, gamma, h02)
    %   dY = odeVelocityCone(theta, Y), function to evaluate the profile speed at each    
    %   angular coordinate theta
    %   
    %   INPUT:  
    %       th,     double[1, 1]: tangential angular coordinate [rad]
    %       Y,      double[2, 1]: state vector: vr, vtheta
    %       h02,    double[1, 1]: post shock total entalpy [J]
    %   OUTPUT:
    %       dY,     double[2, 1]: state derivatives


    uR = Y(1);  % radial component
    uTh = Y(2); % tangential component

    % compute the speed of sound considering
    % h0 = c^2/(gamma - 1) + 0.5 * u^2 = const
    c = sqrt((gamma - 1) * (h02 - 0.5 * (uR^2 + uTh^2)));  

    % compute velocity derivatives
    duR = uTh; 
    duTh = -uR + c^2 * (uR + uTh * cot(th))/(uTh^2 - c^2); 

    dY = [duR; duTh]; 

end


function res = computeBeta(beta, thetaC, M1, T1, gamma, Rg, optOde)
        
        if beta <= thetaC
            error('beta shall be greater or equal than theta'); 
        end

        % retrieve M2 and p2/p1 
        if beta == pi/2
            shockVec = normalShock(M1, gamma, [1, 4]);
        else
            shockVec = obliqueShock(M1, beta, thetaC, gamma, [1, 4]); 
        end

        % post shock conditions
        M2 = shockVec(1); 
        T2 = shockVec(2)*T1; 
        c2 = sqrt(gamma * Rg * T2); 

        % tangential and radial velocity after the shock
        uth2 = -M2 * sin(beta - thetaC) * c2; 
        ur2  = M2 * cos(beta - thetaC) * c2; 
        
        h02 = c2^2/(gamma - 1) + 0.5*M2 *c2;  % post shock total entalpy

        [~, uVec] = ode113(@odeVelocityCone, [beta, thetaC], [ur2; uth2], optOde, gamma, thetaC, h02); 
        
        res = uVec(end, 2) ;
end